// Copyright 2017 Amagicom AB.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! HTTP transport implementation for the JSON-RPC 2.0 clients generated by
//! [`jsonrpc-client-core`](../jsonrpc_client_core/index.html).
//!
//! Uses the async Tokio based version of Hyper to implement a JSON-RPC 2.0 compliant HTTP
//! transport.
//!
//! # Reusing connections
//!
//! Each [`HttpTransport`](struct.HttpTransport.html) instance is backed by exactly one Hyper
//! `Client` and all [`HttpHandle`s](struct.HttpHandle.html) created through the same
//! `HttpTransport` also point to that same `Client` instance.
//!
//! By default Hyper `Client`s have keep-alive activated and open connections will be kept and
//! reused if more requests are sent to the same destination before the keep-alive timeout is
//! reached.
//!
//! # TLS / HTTPS
//!
//! TLS support is compiled if the "tls" feature is enabled.
//!
//! When TLS support is enabled the builder returned from [`HttpTransport::with_tls`] will produce a
//! [`HttpTransport`] supporting both plaintext http and encrypted https over TLS, backed by the
//! `hyper_tls::HttpsConnector` connector.
//!
//! [`HttpTransport`]: struct.HttpTransport.html
//! [`HttpTransport::with_tls`]: struct.HttpTransport.html#method.with_tls
//!
//! # Examples
//!
//! See the integration test in `tests/localhost.rs` for code that creates an actual HTTP server
//! with `jsonrpc_http_server`, and sends requests to it with this crate.
//!
//! Here is a small example of how to use this crate together with `jsonrpc_core`:
//!
//! ```rust,no_run
//! #[macro_use] extern crate jsonrpc_client_core;
//! extern crate jsonrpc_client_http;
//!
//! use jsonrpc_client_http::HttpTransport;
//!
//! jsonrpc_client!(pub struct FizzBuzzClient {
//!     /// Returns the fizz-buzz string for the given number.
//!     pub fn fizz_buzz(&mut self, number: u64) -> RpcRequest<String>;
//! });
//!
//! fn main() {
//!     let transport = HttpTransport::new().standalone().unwrap();
//!     let transport_handle = transport.handle("https://api.fizzbuzzexample.org/rpc/").unwrap();
//!     let mut client = FizzBuzzClient::new(transport_handle);
//!     let result1 = client.fizz_buzz(3).call().unwrap();
//!     let result2 = client.fizz_buzz(4).call().unwrap();
//!     let result3 = client.fizz_buzz(5).call().unwrap();
//!
//!     // Should print "fizz 4 buzz" if the server implemented the service correctly
//!     println!("{} {} {}", result1, result2, result3);
//! }
//! ```

// #![deny(missing_docs)]

#[macro_use]
extern crate error_chain;
extern crate futures;
extern crate jsonrpc_client_core;
#[macro_use]
extern crate log;
extern crate tokio;
extern crate tokio_core;
extern crate tokio_io;

use std::net::SocketAddr;
use tokio_core::reactor::Core;
use futures::{Async, Future, Poll, Stream};
use futures::future;
use futures::sync::{mpsc, oneshot};
use jsonrpc_client_core::Transport;
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

pub use tokio_core::reactor::Handle;
use tokio::net::TcpStream;
use tokio::prelude::*;
use tokio_io::codec::LinesCodec;
use tokio_io::codec::Framed;

error_chain! {
    errors {
        /// When there was an error in the Tokio Core.
        TokioCoreError(msg: &'static str) {
            description("Error with the Tokio Core")
            display("Error with the Tokio Core: {}", msg)
        }

        /// When there was an error connecting the TcpStream.
        TcpStreamConnectError(msg: &'static str) {
            description("Error with the TcpStream connect")
            display("Error with the TcpStream connect: {}", msg)
        }

        /// When there was an error connecting the TcpStream.
        OneShotError(msg: &'static str) {
            description("Error with the TcpStream connect")
            display("Error with the TcpStream connect: {}", msg)
        }
    }

    foreign_links {
        AddrParseError(::std::net::AddrParseError);
        IoError(::std::io::Error);
    }
}

type CoreSender = mpsc::UnboundedSender<(String, oneshot::Sender<Result<Vec<u8>>>)>;
type CoreReceiver = mpsc::UnboundedReceiver<(String, oneshot::Sender<Result<Vec<u8>>>)>;

/// The main struct of the TCP transport implementation for
/// [`jsonrpc_client_core`](../jsonrpc_client_core).
///
/// Acts as a handle to a stream running on the Tokio `Core` event loop thread. The handle allows
/// sending Hyper `Request`s to the event loop and the stream running there will then send it
/// to the destination and wait for the response.
///
/// This is just a handle without any destination (URI), and it does not implement
/// [`Transport`](../jsonrpc_client_core/trait.Transport.html).
/// To get a handle implementing `Transport` to use with an RPC client you call the
/// [`handle`](#method.handle) method with a URI.
#[derive(Debug)]
pub struct TcpTransport {
    request_tx: CoreSender,
    id: Arc<AtomicUsize>,
}

impl TcpTransport {
    /// Creates a `TcpTransport` by connecting a TcpStream.
    pub fn connect(endpoint: &str) -> Result<TcpTransport> {
        let addr = endpoint.parse().unwrap(); //TODO 
        let (tx, rx) = ::std::sync::mpsc::channel();
        thread::spawn(
            move || match create_core(&addr) {
                Err(e) => {
                    tx.send(Err(e)).unwrap();
                }
                Ok((mut core, request_tx, future)) => {
                    tx.send(Ok(Self::build(request_tx))).unwrap();
                    if let Err(_) = core.run(future) {
                        error!("JSON-RPC processing thread had an error");
                    }
                    debug!("Standalone HttpTransport thread exiting");
                }
            },
        );

        rx.recv().unwrap()
    }

    fn build(request_tx: CoreSender) -> TcpTransport {
        TcpTransport {
            request_tx,
            id: Arc::new(AtomicUsize::new(1)),
        }
    }
}

/// Creates all the components needed to run the `TcpTransport`.
fn create_core(addr: &SocketAddr) -> Result<(Core, CoreSender, Box<Future<Item = (), Error = ()>>)> {
    let core = Core::new().chain_err(|| ErrorKind::TokioCoreError("Unable to create"))?;
    let tcp_stream = TcpStream::connect(addr).wait().chain_err(|| ErrorKind::TcpStreamConnectError("Unable to connect"))?;
    let socket = tcp_stream.framed(LinesCodec::new());
    let (request_tx, request_rx) = mpsc::unbounded();
    let future = create_request_processing_future(request_rx, socket);
    Ok((core, request_tx, future))
}

/// Creates the `Future` that, when running on a Tokio Core, processes incoming RPC call
/// requests.
fn create_request_processing_future(
    request_rx: CoreReceiver,
    socket: Framed<TcpStream, LinesCodec>,
) -> Box<Future<Item = (), Error = ()>> {
    let response_tx = None;
    let processor = Processor { request_rx, socket, response_tx }
        .map_err(|e| {
            error!("connection processing error: {:?}", e);
        });
    Box::new(processor)
}

struct Processor {
    request_rx: CoreReceiver,
    socket: Framed<TcpStream, LinesCodec>,
    response_tx: Option<oneshot::Sender<Result<Vec<u8>>>>
}

impl Future for Processor {
    type Item = ();
    type Error = Error;

    fn poll(&mut self) -> Poll<(), Error> {
        if let Some(response_tx) = self.response_tx.take() {
            if let Async::Ready(response) = self.socket.poll()? {
                if let Some(response) = response {
                    if let Err(_) = response_tx.send(Ok(response.as_bytes().to_vec())) {
                        return Err(ErrorKind::OneShotError("Transport disconnected while waiting for response.").into());
                    }
                    task::current().notify();
                } else {
                    return Ok(Async::Ready(()));
                }
            } else {
                // We didn't use the response_tx, put it back.
                self.response_tx = Some(response_tx);
            }
        }
        else if let Async::Ready(request) = self.request_rx.poll().unwrap() {
            if let Some((request, response_tx)) = request {
                self.socket.start_send(request)?;
                self.socket.poll_complete()?;
                self.response_tx = Some(response_tx);
                task::current().notify();
            } else {
                return Ok(Async::Ready(()));
            }

        }
        Ok(Async::NotReady)

    }
}

impl Transport for TcpTransport {
    type Future = Box<Future<Item = Vec<u8>, Error = Self::Error> + Send>;
    type Error = Error;

    fn get_next_id(&mut self) -> u64 {
        self.id.fetch_add(1, Ordering::SeqCst) as u64
    }

    fn send(&self, json_data: Vec<u8>) -> Self::Future {
        let json_string = std::str::from_utf8(&json_data).unwrap().to_string(); //TODO
        let (response_tx, response_rx) = oneshot::channel();
        let future = future::result(self.request_tx.unbounded_send((json_string, response_tx)))
            .map_err(|e| {
                Error::with_chain(e, ErrorKind::TokioCoreError("Not listening for requests"))
            })
            .and_then(move |_| {
                response_rx.map_err(|e| {
                    Error::with_chain(
                        e,
                        ErrorKind::TokioCoreError("Died without returning response"),
                    )
                })
            })
            .and_then(future::result);
        Box::new(future)
    }
}


// #[cfg(test)]
// mod tests {
//     use super::*;
//     use hyper::client::HttpConnector;
//     use std::io;

//     #[test]
//     fn new_shared() {
//         let core = Core::new().unwrap();
//         HttpTransport::new().shared(&core.handle()).unwrap();
//     }

//     #[test]
//     fn new_standalone() {
//         HttpTransport::new().standalone().unwrap();
//     }

//     #[test]
//     fn new_custom_client() {
//         HttpTransportBuilder::with_client(|handle: &Handle| {
//             Ok(Client::configure().keep_alive(false).build(handle)) as Result<_>
//         }).standalone()
//             .unwrap();
//     }

//     #[test]
//     fn failing_client_creator() {
//         let error = HttpTransportBuilder::with_client(|_: &Handle| {
//             Err(io::Error::new(io::ErrorKind::Other, "Dummy error"))
//                 as ::std::result::Result<Client<HttpConnector, hyper::Body>, io::Error>
//         }).standalone()
//             .unwrap_err();
//         match error.kind() {
//             &ErrorKind::ClientCreatorError => (),
//             kind => panic!("invalid error kind response: {:?}", kind),
//         }
//     }
// }
